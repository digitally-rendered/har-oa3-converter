"""Command-line interface for format converter."""

import argparse
import sys
from pathlib import Path
from typing import List, Optional

from har_oa3_converter.converters.format_converter import (
    convert_file,
    guess_format_from_file,
)

# Import directly from format_registry to get the correct implementation
from har_oa3_converter.converters.format_registry import (
    get_available_formats,
    get_converter_for_formats,
)
from har_oa3_converter.utils import (
    active_conversions,
    api_requests,
    conversion_counter,
    conversion_duration,
    conversion_metrics,
    get_logger,
    timed,
    traced,
)

# Get a logger for this module
logger = get_logger(__name__)


def parse_args(args: Optional[List[str]] = None) -> argparse.Namespace:
    """Parse command line arguments.

    Args:
        args: Command line arguments (None uses sys.argv)

    Returns:
        Parsed arguments
    """
    available_formats = get_available_formats()
    format_list = ", ".join(available_formats)

    # Create a parser for just the --list-formats flag
    list_parser = argparse.ArgumentParser(add_help=False)
    list_parser.add_argument(
        "--list-formats", help="List available formats and exit", action="store_true"
    )

    # Parse just to check if --list-formats is present
    list_args, _ = list_parser.parse_known_args(args)

    # Create the main parser
    parser = argparse.ArgumentParser(
        description="Convert between API specification formats"
    )

    # Add the --list-formats argument
    parser.add_argument(
        "--list-formats", help="List available formats and exit", action="store_true"
    )

    # Make input and output optional when --list-formats is used
    if list_args.list_formats:
        parser.add_argument("input", help="Path to input file", nargs="?", default=None)
        parser.add_argument(
            "output", help="Path to output file", nargs="?", default=None
        )
    else:
        parser.add_argument("input", help="Path to input file")
        parser.add_argument("output", help="Path to output file")

    parser.add_argument(
        "--from-format",
        help=f"Source format (available: {format_list}). If not specified, will be guessed from input file",
        choices=available_formats,
    )

    parser.add_argument(
        "--to-format",
        help=f"Target format (available: {format_list}). If not specified, will be guessed from output file",
        choices=available_formats,
    )

    # OpenAPI/Swagger specific arguments
    parser.add_argument(
        "--title",
        help="API title (for OpenAPI/Swagger output)",
        default="API Specification",
    )

    parser.add_argument(
        "--version", help="API version (for OpenAPI/Swagger output)", default="1.0.0"
    )

    parser.add_argument(
        "--description",
        help="API description (for OpenAPI/Swagger output)",
        default="API specification generated by format-converter",
    )

    parser.add_argument(
        "--server",
        help="Server URL (can be specified multiple times)",
        action="append",
        dest="servers",
        default=[],
    )

    parser.add_argument("--base-path", help="Base path for API endpoints", default=None)

    # --list-formats is already added above

    parser.add_argument(
        "--no-validate",
        help="Skip schema validation of input file",
        action="store_true",
    )

    return parser.parse_args(args)


@traced(span_name="format_cli_main")
def main(args: Optional[List[str]] = None) -> int:
    """Main entry point for the CLI.

    Args:
        args: Command line arguments (None uses sys.argv)

    Returns:
        Exit code
    """
    # Get tracer for this operation
    parsed_args = parse_args(args)

    # Handle listing available formats
    if parsed_args.list_formats:
        # Get available formats
        formats = get_available_formats()
        logger.info("Available formats:")
        for fmt in formats:
            logger.info(f"  - {fmt}")

        # List available conversions
        logger.info("\nAvailable conversions:")
        for source_format in formats:
            for target_format in formats:
                converter = get_converter_for_formats(source_format, target_format)
                if converter:
                    logger.info(f"  - {source_format} â†’ {target_format}")
        return 0

    # If we're not listing formats, input and output are required
    if not parsed_args.input or not parsed_args.output:
        logger.error(
            "Both input and output files are required unless using --list-formats"
        )
        return 1

    input_path = parsed_args.input
    output_path = parsed_args.output

    # Check if input file exists
    if not Path(input_path).exists():
        logger.error(f"Input file '{input_path}' does not exist")
        return 1

    # Parse format arguments
    input_source_format: str = parsed_args.from_format or ""
    input_target_format: str = parsed_args.to_format or ""

    source_format = input_source_format
    if not source_format:
        source_format_guess = guess_format_from_file(input_path)
        if source_format_guess:
            source_format = source_format_guess
        if source_format:
            logger.info(f"Detected source format: {source_format}")
        else:
            logger.error(
                f"Could not detect source format for '{input_path}'. Please specify with --from-format"
            )
            return 1

    target_format = input_target_format
    if not target_format:
        # For target format, we first try to guess from the output file extension
        # If that fails, we'll try to determine from the available converters
        target_format_guess = guess_format_from_file(output_path)
        if target_format_guess:
            target_format = target_format_guess
        if target_format:
            logger.info(f"Detected target format: {target_format}")
        else:
            logger.error(
                f"Could not detect target format for '{output_path}'. Please specify with --to-format"
            )
            return 1

    # Check if conversion is available
    converter = get_converter_for_formats(source_format, target_format)
    if not converter:
        logger.error(f"No converter available for {source_format} to {target_format}")
        logger.error("Use --list-formats to see available conversions")
        return 1

    # Create options dict from arguments
    options = {
        "title": parsed_args.title,
        "version": parsed_args.version,
        "description": parsed_args.description,
        "servers": parsed_args.servers,
        "base_path": parsed_args.base_path,
        "validate_schema": not parsed_args.no_validate,
    }

    # Perform conversion
    try:
        logger.info(f"Converting {source_format} to {target_format}...")
        # Increment active conversion gauge
        active_conversions.inc()

        # Record metrics for this conversion
        with conversion_duration.labels(
            source_format=source_format, target_format=target_format
        ).time():
            convert_file(
                input_path, output_path, source_format, target_format, **options
            )

        # Record successful conversion
        conversion_counter.labels(
            source_format=source_format, target_format=target_format, status="success"
        ).inc()

        logger.info(f"Conversion successful: {output_path}")
        return 0
    except Exception as e:
        # Record failed conversion
        conversion_counter.labels(
            source_format=source_format, target_format=target_format, status="error"
        ).inc()

        logger.error(f"Error during conversion: {str(e)}")
        return 1
    finally:
        # Always decrement the active conversions gauge
        active_conversions.dec()


if __name__ == "__main__":
    sys.exit(main())
